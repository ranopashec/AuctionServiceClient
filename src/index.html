<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Электронный аукцион — клиент</title>
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; color:#111; }
h1 { font-size: 20px; margin-bottom: 8px; }
.controls { margin-bottom: 12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
input, button, select { padding:6px 8px; font-size:14px; }
table { border-collapse: collapse; width:100%; margin-top:12px; }
th, td { border:1px solid #ddd; padding:8px; text-align:left; }
th { background:#f2f2f2; }
.small { font-size:12px; color:#666; }
.btn { padding:6px 10px; cursor:pointer; border:1px solid #888; background:#fff; border-radius:6px; }
.btn-primary { background:#2563eb; color:white; border-color:transparent; }
.btn-danger { background:#ef4444; color:white; border-color:transparent; }
.inline-edit { min-width:120px; }
.token-info { font-size:12px; margin-left:8px; }
.error { color:#b91c1c; font-weight:600; }
.success { color:#065f46; font-weight:600; }
#bidModal { display:none; position:fixed; left:0; top:0; right:0; bottom:0; background: rgba(0,0,0,0.4); align-items:center; justify-content:center; }
#bidModal .panel { background:white; padding:16px; border-radius:8px; width:320px; }
#newLotForm { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
#newLotForm input { width:200px; }
.debug-panel { background:#f3f4f6; border:1px solid #d1d5db; padding:12px; margin:12px 0; border-radius:6px; }
.debug-panel h4 { margin:0 0 8px 0; color:#374151; font-size:14px; }
.debug-output { margin-top:8px; font-family:monospace; font-size:11px; max-height:200px; overflow-y:auto; background:#1f2937; color:#f3f4f6; padding:8px; border-radius:4px; }
.debug-line { margin:2px 0; padding:2px 4px; }
.debug-line.success { color:#4ade80; }
.debug-line.error { color:#f87171; }
.debug-line.info { color:#60a5fa; }
</style>
</head>
<body>

<h1>Клиент: Электронный аукцион — продажа земельных участков</h1>

<div class="debug-panel">
  <h4>Отладка токенов</h4>
  <div style="display:flex; gap:8px; margin-bottom:8px;">
    <button class="btn" onclick="testTokenFormats()">Тестировать форматы токена</button>
    <button class="btn" onclick="showRawToken()">Показать токен</button>
    <button class="btn" onclick="clearAllTokens()">Очистить токены</button>
    <select id="tokenFormatSelect" style="margin-left:auto;">
      <option value="Bearer">Bearer формат</option>
      <option value="Token">Token формат</option>
      <option value="Raw">Raw формат</option>
      <option value="X-Auth-Token">X-Auth-Token заголовок</option>
    </select>
    <button class="btn btn-primary" onclick="saveTokenFormat()">Сохранить формат</button>
  </div>
  <div id="debugOutput" class="debug-output"></div>
</div>

<div class="controls">
  <label class="small">Auction URL:
    <input id="cfgAuctionUrl" value="https://auctionservice2-production.up.railway.app" style="width:220px"/>
  </label>
  <label class="small">Payment URL:
    <input id="cfgPaymentUrl" value="https://payment-service-15044579133.europe-central2.run.app" style="width:220px"/>
  </label>
  <label class="small">Organization ID:
    <input id="cfgOrgId" value="org-123" style="width:140px"/>
  </label>
  <button class="btn btn-primary" id="btnRequestBill">Сформировать счет</button>
  <button class="btn btn-primary" id="btnPayBill">Оплатить счет</button>
  <div style="margin-left:auto; display:flex; align-items:center;">
    <button class="btn" id="btnShowTokens">Токены</button>
    <div id="tokenStatus" class="token-info"></div>
  </div>
</div>

<div id="messages"></div>

<h3>Добавить новый лот</h3>
<form id="newLotForm">
  <input id="new_name" placeholder="Название" required/>
  <input id="new_start_price" placeholder="Стартовая цена" type="number" step="0.01" required/>
  <input id="new_auction_end_date" placeholder="Дата окончания (гггг-мм-дд)" value=""/>
  <input id="new_description" placeholder="Описание"/>
  <button class="btn btn-primary" type="submit">Создать (CreateLot)</button>
</form>

<h3>Список лотов</h3>
<div class="small">Двойной клик на ячейке — редактировать. Сохранить — UpdateLot. Создание/удаление/ставки — платные методы.</div>

<table id="lotsTable">
  <thead>
    <tr>
      <th>ID</th>
      <th>Название</th>
      <th>Описание</th>
      <th>Стартовая цена</th>
      <th>Текущая цена</th>
      <th>Владелец</th>
      <th>Окончание аукциона</th>
      <th>Действия</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<div id="bidModal">
  <div class="panel">
    <h4>Сделать ставку</h4>
    <div id="bidLotInfo"></div>
    <div style="margin-top:8px">
      <input id="bid_amount" type="number" step="0.01" placeholder="Сумма ставки" style="width:150px"/>
      <button class="btn btn-primary" id="btnPlaceBid">Поставить (PlaceBid)</button>
      <button class="btn" id="btnCloseBid">Отмена</button>
    </div>
    <div id="bidMessage" class="small" style="margin-top:8px"></div>
  </div>
</div>

<script>
const cfg = {
  get auctionUrl(){ return document.getElementById('cfgAuctionUrl').value.replace(/\/+$/,''); },
  get paymentUrl(){ return document.getElementById('cfgPaymentUrl').value.replace(/\/+$/,''); },
  get orgId(){ return document.getElementById('cfgOrgId').value.trim(); },
  serviceName: "AuctionService"
};

// Конфигурация прокси
const PROXY_CONFIG = {
  enabled: true,
  endpoint: '/api/proxy'
};

// Конфигурация формата токена
const TOKEN_CONFIG = {
  format: localStorage.getItem('token_format') || 'Bearer',
  customHeader: localStorage.getItem('token_custom_header') || null
};

const state = {
  lots: [],
  editing: new Map(),
  paymentArtifact: null,
  tokens: loadTokens()
};

function showMessage(text,type='info',ttl=4000){
  const box = document.getElementById('messages');
  box.innerHTML=`<div class="${type==='error'?'error':type==='success'?'success':''}">${text}</div>`;
  if(ttl>0)setTimeout(()=>{ if(box.innerHTML.includes(text)) box.innerHTML=''; },ttl);
}

function debugLog(msg, type='info') {
  const el = document.getElementById('debugOutput');
  const line = document.createElement('div');
  line.className = `debug-line ${type}`;
  line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  el.appendChild(line);
  el.scrollTop = el.scrollHeight;
  console.log(`[DEBUG] ${msg}`);
}

function loadTokens(){ 
  try { 
    const tokens = JSON.parse(localStorage.getItem('auction_tokens')||'{}');
    debugLog(`Загружено ${Object.keys(tokens).length} токенов`, 'info');
    return tokens; 
  } catch(e){ 
    debugLog('Ошибка загрузки токенов: ' + e.message, 'error');
    return {}; 
  }
}

function saveTokens(){ 
  localStorage.setItem('auction_tokens',JSON.stringify(state.tokens)); 
  updateTokenStatusUI();
  debugLog('Токены сохранены', 'success');
}

function updateTokenStatusUI(){
  const el = document.getElementById('tokenStatus');
  const keys = Object.keys(state.tokens);
  
  if(keys.length===0){ 
    el.textContent='Нет токенов'; 
    el.style.color = '#dc2626';
    return; 
  }
  
  let soonest = null;
  let methodsList = [];
  keys.forEach(k=>{
    const t = state.tokens[k];
    if(!t || !t.token) return;
    if(t.expiresAt){
      const d = new Date(t.expiresAt);
      if(isNaN(d)) return;
      if(!soonest || d < soonest) soonest = d;
    }
    methodsList.push(k);
  });
  
  el.textContent = `${methodsList.length} метод(ов): ${methodsList.join(', ')}`;
  el.style.color = '#16a34a';
  
  if(soonest){
    el.textContent += ` (до ${soonest.toLocaleDateString('ru-RU')})`;
  }
}

// получение токена для конкретного метода
function tokenForMethod(method){
  const info=state.tokens[method];
  if(!info) {
    debugLog(`Токен для метода "${method}" не найден`, 'error');
    return null;
  }
  
  if(info.expiresAt && new Date(info.expiresAt).getTime() < Date.now()){
    delete state.tokens[method];
    saveTokens();
    debugLog(`Токен для метода "${method}" истек`, 'error');
    return null;
  }
  
  debugLog(`Токен для метода "${method}" получен (длина: ${info.token?.length || 0})`, 'success');
  return info.token;
}

// Улучшенная функция fetch с поддержкой прокси
async function fetchWithProxy(url, options = {}) {
  if (!PROXY_CONFIG.enabled || url.startsWith('/') || url.includes(location.origin)) {
    return await directFetch(url, options);
  }
  
  try {
    debugLog(`Прокси запрос: ${url}`, 'info');
    const proxyResponse = await fetch(PROXY_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        url: url,
        options: options
      })
    });
    
    if (!proxyResponse.ok) {
      const errorText = await proxyResponse.text();
      throw new Error(`Proxy error: ${proxyResponse.status} - ${errorText}`);
    }
    
    const result = await proxyResponse.json();
    debugLog(`Прокси ответ: ${JSON.stringify(result).substring(0, 100)}`, 'success');
    return result;
    
  } catch (proxyError) {
    debugLog('Прокси не сработал: ' + proxyError.message, 'error');
    
    try {
      debugLog('Пробуем прямой запрос...', 'info');
      return await directFetch(url, options);
    } catch (directError) {
      debugLog('Прямой запрос не сработал: ' + directError.message, 'error');
      return await fetchWithPublicProxy(url, options);
    }
  }
}

// Прямой fetch запрос
async function directFetch(url, options = {}) {
  debugLog(`Прямой запрос: ${options.method || 'GET'} ${url}`, 'info');
  
  // Логируем заголовки
  if (options.headers) {
    debugLog(`Заголовки: ${JSON.stringify(options.headers)}`, 'info');
  }
  
  const response = await fetch(url, {
    ...options,
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json',
      ...options.headers
    }
  });
  
  const text = await response.text();
  debugLog(`Ответ: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
  debugLog(`Тело ответа: ${text.substring(0, 200)}`, 'info');
  
  let body = null;
  
  try {
    body = text ? JSON.parse(text) : null;
  } catch (e) {
    debugLog('Ошибка парсинга JSON: ' + e.message, 'error');
    body = { text: text };
  }
  
  if (!response.ok) {
    const err = new Error(body?.error || body?.message || body?.text || `HTTP ${response.status}`);
    err.status = response.status;
    err.body = body;
    throw err;
  }
  
  return body;
}

// Использование публичных CORS прокси в крайнем случае
async function fetchWithPublicProxy(url, options = {}) {
  debugLog('Пробуем публичные прокси...', 'info');
  const publicProxies = [
    'https://api.allorigins.win/raw?url=',
    'https://corsproxy.io/?',
    'https://thingproxy.freeboard.io/fetch/'
  ];
  
  for (const proxy of publicProxies) {
    try {
      const proxyUrl = proxy + encodeURIComponent(url);
      debugLog(`Пробуем прокси: ${proxy}`, 'info');
      const response = await fetch(proxyUrl, options);
      
      if (response.ok) {
        const text = await response.text();
        debugLog(`Публичный прокси сработал: ${proxy}`, 'success');
        return text ? JSON.parse(text) : null;
      }
    } catch (e) {
      debugLog(`Прокси ${proxy} не сработал: ${e.message}`, 'error');
    }
  }
  
  throw new Error('All fetch methods failed');
}

// Основная функция для всех запросов с авторизацией
async function fetchJson(url, options = {}, methodName = null) {
  debugLog(`fetchJson: ${methodName || 'NO_AUTH'} ${options.method || 'GET'} ${url}`, 'info');
  
  // Автоматически добавляем токен авторизации для платных методов
  if (methodName) {
    const token = tokenForMethod(methodName);
    if (token) {
      // Формируем заголовок авторизации согласно конфигурации
      if (TOKEN_CONFIG.customHeader) {
        options.headers = {
          ...options.headers,
          [TOKEN_CONFIG.customHeader]: token
        };
        debugLog(`Используем кастомный заголовок: ${TOKEN_CONFIG.customHeader}: ${token.substring(0, 20)}...`, 'success');
      } else {
        let authHeader;
        switch(TOKEN_CONFIG.format) {
          case 'Bearer':
            authHeader = 'Bearer ' + token;
            break;
          case 'Token':
            authHeader = 'Token ' + token;
            break;
          case 'Raw':
            authHeader = token;
            break;
          default:
            authHeader = 'Bearer ' + token;
        }
        
        options.headers = {
          ...options.headers,
          'Authorization': authHeader
        };
        debugLog(`Используем формат ${TOKEN_CONFIG.format}: Authorization: ${authHeader.substring(0, 30)}...`, 'success');
      }
    } else {
      const msg = `Для метода "${methodName}" требуется оплата. Сформируйте и оплатите счет.`;
      showMessage(msg, 'error');
      debugLog(msg, 'error');
      throw new Error(`Token required for ${methodName}`);
    }
  }
  
  return await fetchWithProxy(url, options);
}

/* ====== Payment ====== */
async function requestBill(periodFrom, periodTo, methods) {
  try {
    const payload = { 
      serviceName: cfg.serviceName, 
      dateFrom: periodFrom, 
      dateTo: periodTo, 
      methods 
    };
    
    debugLog(`Формируем счет для методов: ${methods.join(', ')}`, 'info');
    
    const body = await fetchJson(cfg.paymentUrl + '/bill', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    
    state.paymentArtifact = body.paymentArtifact;
    debugLog(`Счет сформирован. Артефакт: ${body.paymentArtifact}`, 'success');
    showMessage(`Счёт сформирован. Артефакт: ${body.paymentArtifact}`, 'success');
  } catch(err) { 
    debugLog('Ошибка формирования счета: ' + err.message, 'error');
    showMessage('Ошибка формирования счета: ' + (err.body?.description || err.message || err.toString()), 'error'); 
  }
}

async function payBill() {
  if (!state.paymentArtifact) { 
    showMessage('Сначала сформируйте счёт', 'error'); 
    return; 
  }
  
  try {
    const payload = { paymentArtifact: state.paymentArtifact };
    debugLog(`Оплачиваем счет: ${state.paymentArtifact}`, 'info');
    
    const body = await fetchJson(cfg.paymentUrl + '/pay', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    
    debugLog(`Ответ оплаты: ${JSON.stringify(body)}`, 'info');
    
    if (!body.token) { 
      showMessage('Ошибка: токен не получен', 'error'); 
      return; 
    }
    
    debugLog(`Получен токен длиной ${body.token.length} символов`, 'success');
    debugLog(`Токен (первые 50): ${body.token.substring(0, 50)}...`, 'info');
    
    const info = await fetchJson(cfg.paymentUrl + '/payment/info', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ paymentArtifact: state.paymentArtifact })
    });
    
    debugLog(`Информация об оплате: ${JSON.stringify(info)}`, 'info');
    
    info.methods.forEach(m => {
      state.tokens[m] = { 
        token: body.token, 
        expiresAt: info.paidUntil || null 
      };
      debugLog(`Токен сохранен для метода: ${m}`, 'success');
    });
    
    saveTokens();
    
    // Показать токен для отладки
    alert(`✅ Токен получен!\n\nДлина: ${body.token.length} символов\nФормат: ${TOKEN_CONFIG.format}${TOKEN_CONFIG.customHeader ? ` (заголовок: ${TOKEN_CONFIG.customHeader})` : ''}\n\nПервые 50 символов:\n${body.token.substring(0, 50)}...`);
    
    showMessage('Оплата прошла успешно. Токены для методов получены', 'success');
    state.paymentArtifact = null;
  } catch(err) { 
    debugLog('Ошибка оплаты: ' + err.message, 'error');
    showMessage('Оплата не удалась: ' + (err.body?.description || err.message || err.toString()), 'error'); 
  }
}

/* ====== CRUD + Bid ====== */
async function loadLots() {
  try {
    debugLog('Загружаем лоты...', 'info');
    const body = await fetchJson(cfg.auctionUrl + '/lots');
    state.lots = Array.isArray(body) ? body : [];
    renderTable();
    debugLog(`Загружено ${state.lots.length} лотов`, 'success');
    showMessage('Лоты загружены', 'success', 1500);
  } catch(err) { 
    debugLog('Ошибка загрузки лотов: ' + err.message, 'error');
    showMessage('Не удалось загрузить лоты: ' + (err.body?.error || err.message || err.toString()), 'error'); 
  }
}

function renderTable() {
  const tbody = document.querySelector('#lotsTable tbody');
  tbody.innerHTML = '';
  
  for (const lot of state.lots) {
    const tr = document.createElement('tr');
    tr.dataset.id = lot.id;
    tr.innerHTML = `
      <td>${lot.id}</td>
      <td class="editable" data-field="name">${escapeHtml(lot.name ?? '')}</td>
      <td class="editable" data-field="description">${escapeHtml(lot.description ?? '')}</td>
      <td>${lot.start_price ?? 0}</td>
      <td>${lot.current_price ?? '-'}</td>
      <td class="editable" data-field="owner_id">${escapeHtml(lot.owner_id ?? '')}</td>
      <td class="editable" data-field="auction_end_date">${escapeHtml(formatDateForDisplay(lot.auction_end_date ?? ''))}</td>
      <td>
        <button class="btn" data-action="save">Save</button>
        <button class="btn" data-action="delete">Delete</button>
        <button class="btn" data-action="bid">Bid</button>
      </td>
    `;
    tbody.appendChild(tr);
  }

  // Редактирование по двойному клику
  document.querySelectorAll('#lotsTable td.editable').forEach(td => {
    td.ondblclick = () => {
      const prev = td.textContent;
      td.contentEditable = "true";
      td.classList.add('editing');
      td.focus();
      
      td.onblur = () => {
        td.contentEditable = "false";
        td.onblur = null;
        const id = td.parentElement.dataset.id;
        const field = td.dataset.field;
        
        if (!state.editing[id]) state.editing[id] = {};
        state.editing[id][field] = td.textContent.trim();
      };
    };
  });

  // Обработчики кнопок
  document.querySelectorAll('#lotsTable button').forEach(btn => {
    btn.onclick = async (e) => {
      const tr = e.target.closest('tr');
      const id = tr.dataset.id;
      const action = e.target.dataset.action;
      
      if (action === 'save') await handleSave(id, tr);
      if (action === 'delete') await handleDelete(id);
      if (action === 'bid') await openBidModal(id);
    };
  });
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  }[c]));
}

function formatDateForDisplay(dateString) {
  if (!dateString) return '';
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('ru-RU');
  } catch (e) {
    return dateString;
  }
}

function formatDateForAPI(dateString) {
  if (!dateString) return '';
  if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
    return dateString;
  }
  try {
    const date = new Date(dateString);
    return date.toISOString().split('T')[0];
  } catch (e) {
    return dateString;
  }
}

async function handleSave(id, tr) {
  const edits = state.editing[id];
  if (!edits || Object.keys(edits).length === 0) {
    showMessage('Нет изменений', 'info');
    return;
  }
  
  const payload = {};
  if ('name' in edits) payload.name = edits.name;
  if ('description' in edits) payload.description = edits.description;
  if ('owner_id' in edits) payload.owner_id = edits.owner_id;
  if ('auction_end_date' in edits) payload.auction_end_date = formatDateForAPI(edits.auction_end_date);
  
  try {
    debugLog(`Обновляем лот ${id}: ${JSON.stringify(payload)}`, 'info');
    await fetchJson(cfg.auctionUrl + '/lots/' + encodeURIComponent(id), {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }, 'UpdateLot');
    
    delete state.editing[id];
    await loadLots();
    debugLog(`Лот ${id} обновлен`, 'success');
    showMessage('Lot обновлён', 'success');
  } catch(err) {
    debugLog(`Ошибка обновления лота ${id}: ${err.message}`, 'error');
    showMessage('Ошибка при обновлении: ' + (err.body?.error || err.message || err.toString()), 'error');
  }
}

async function handleDelete(id) {
  if (!confirm('Удалить лот #' + id + '?')) return;
  
  try {
    debugLog(`Удаляем лот ${id}`, 'info');
    await fetchJson(cfg.auctionUrl + '/lots/' + encodeURIComponent(id), {
      method: 'DELETE'
    }, 'DeleteLot');
    
    await loadLots();
    debugLog(`Лот ${id} удален`, 'success');
    showMessage('Lot удалён', 'success');
  } catch(err) {
    debugLog(`Ошибка удаления лота ${id}: ${err.message}`, 'error');
    showMessage('Не удалось удалить: ' + (err.body?.error || err.message || err.toString()), 'error');
  }
}

// Создание нового лота
document.getElementById('newLotForm').onsubmit = async (e) => {
  e.preventDefault();
  
  const name = document.getElementById('new_name').value.trim();
  const start_price = parseFloat(document.getElementById('new_start_price').value);
  const auction_end_date = document.getElementById('new_auction_end_date').value.trim();
  const description = document.getElementById('new_description').value.trim();
  
  if (!name || isNaN(start_price)) {
    showMessage('Заполните имя и стартовую цену', 'error');
    return;
  }
  
  const payload = {
    name,
    start_price,
    auction_end_date: formatDateForAPI(auction_end_date) || undefined,
    description: description || undefined
  };
  
  try {
    debugLog(`Создаем лот: ${JSON.stringify(payload)}`, 'info');
    await fetchJson(cfg.auctionUrl + '/lots', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }, 'CreateLot');
    
    showMessage('Лот создан', 'success');
    e.target.reset();
    await loadLots();
    debugLog('Лот создан успешно', 'success');
  } catch(err) {
    debugLog(`Ошибка создания лота: ${err.message}`, 'error');
    showMessage('Ошибка при создании: ' + (err.body?.error || err.message || err.toString()), 'error');
  }
};

/* ---------- Ставки ---------- */
let currentBidLotId = null;

async function openBidModal(id) {
  currentBidLotId = id;
  const lot = state.lots.find(l => String(l.id) === String(id));
  const currentPrice = lot.current_price ?? lot.start_price ?? 0;
  
  document.getElementById('bidLotInfo').textContent = lot ? 
    `${lot.id} — ${lot.name} (текущая: ${currentPrice})` : 
    `Лот ${id}`;
  
  document.getElementById('bid_amount').value = '';
  document.getElementById('bid_amount').min = (currentPrice + 0.01).toFixed(2);
  document.getElementById('bid_amount').placeholder = `Минимум ${(currentPrice + 0.01).toFixed(2)}`;
  document.getElementById('bidMessage').textContent = '';
  document.getElementById('bidModal').style.display = 'flex';
}

document.getElementById('btnCloseBid').onclick = () => {
  document.getElementById('bidModal').style.display = 'none';
};

document.getElementById('btnPlaceBid').onclick = async () => {
  const amount = parseFloat(document.getElementById('bid_amount').value);
  const lot = state.lots.find(l => String(l.id) === String(currentBidLotId));
  const currentPrice = lot.current_price ?? lot.start_price ?? 0;
  
  if (isNaN(amount) || amount <= 0) {
    document.getElementById('bidMessage').textContent = 'Введите корректную сумму';
    return;
  }
  
  if (amount <= currentPrice) {
    document.getElementById('bidMessage').textContent = `Ставка должна быть больше текущей цены (${currentPrice})`;
    return;
  }
  
  try {
    debugLog(`Ставка на лот ${currentBidLotId}: ${amount}`, 'info');
    await fetchJson(cfg.auctionUrl + '/lots/' + encodeURIComponent(currentBidLotId) + '/bid', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ bid_amount: amount })
    }, 'PlaceBid');
    
    document.getElementById('bidMessage').textContent = 'Ставка принята';
    debugLog(`Ставка ${amount} на лот ${currentBidLotId} принята`, 'success');
    await loadLots();
    setTimeout(() => {
      document.getElementById('bidModal').style.display = 'none';
    }, 800);
  } catch(err) {
    debugLog(`Ошибка ставки: ${err.message}`, 'error');
    const errorMsg = err.body?.error || err.message || err.status || err.toString();
    
    if (errorMsg.includes('greater than current price')) {
      document.getElementById('bidMessage').textContent = 'Ставка должна быть больше текущей цены';
    } else if (errorMsg.includes('Auction has ended')) {
      document.getElementById('bidMessage').textContent = 'Аукцион уже завершен';
    } else if (err.message.includes('Token required')) {
      document.getElementById('bidMessage').textContent = 'Для ставок требуется оплатить метод PlaceBid';
    } else {
      document.getElementById('bidMessage').textContent = 'Ошибка: ' + errorMsg;
    }
  }
};

/* ---------- UI кнопки ---------- */
document.getElementById('btnRequestBill').onclick = () => {
  const now = new Date();
  const later = new Date(now.getTime() + 1000 * 60 * 60 * 24);
  const dateFrom = now.toISOString().split('T')[0];
  const dateTo = later.toISOString().split('T')[0];
  
  requestBill(dateFrom, dateTo, ['CreateLot', 'UpdateLot', 'DeleteLot', 'PlaceBid']);
};

document.getElementById('btnPayBill').onclick = payBill;

document.getElementById('btnShowTokens').onclick = () => {
  const keys = Object.keys(state.tokens || {});
  if (keys.length === 0) {
    alert('Токенов нет. Сначала оплатите методы через "Сформировать счет" и "Оплатить счет".');
    return;
  }
  
  let txt = 'ОПЛАЧЕННЫЕ МЕТОДЫ:\n\n';
  keys.forEach(k => {
    const tokenInfo = state.tokens[k];
    const expires = tokenInfo.expiresAt ? 
      new Date(tokenInfo.expiresAt).toLocaleString('ru-RU') : 
      '(без срока)';
    const tokenPreview = tokenInfo.token ? 
      tokenInfo.token.substring(0, 20) + '...' : 
      'Нет токена';
    
    txt += `${k}\n`;
    txt += `  Токен: ${tokenPreview}\n`;
    txt += `  Истекает: ${expires}\n`;
    txt += '─'.repeat(40) + '\n';
  });
  
  txt += `\nВсего оплачено методов: ${keys.length}`;
  txt += `\nФормат токена: ${TOKEN_CONFIG.format}`;
  if (TOKEN_CONFIG.customHeader) {
    txt += `\nКастомный заголовок: ${TOKEN_CONFIG.customHeader}`;
  }
  
  alert(txt);
};

/* ---------- Отладочные функции ---------- */
async function testTokenFormats() {
  debugLog('=== Тестирование форматов токена ===', 'info');
  
  const token = tokenForMethod('CreateLot') || Object.values(state.tokens)[0]?.token;
  
  if (!token) {
    debugLog('❌ Нет токена для тестирования. Сначала оплатите методы.', 'error');
    alert('Сначала оплатите методы через "Сформировать счет" и "Оплатить счет".');
    return;
  }
  
  debugLog(`Токен для тестирования (длина ${token.length}): ${token.substring(0, 50)}...`, 'info');
  
  const testCases = [
    { name: 'Bearer', getHeader: () => ({ 'Authorization': 'Bearer ' + token }) },
    { name: 'Token', getHeader: () => ({ 'Authorization': 'Token ' + token }) },
    { name: 'Raw', getHeader: () => ({ 'Authorization': token }) },
    { name: 'X-Auth-Token', getHeader: () => ({ 'X-Auth-Token': token }) },
    { name: 'X-Access-Token', getHeader: () => ({ 'X-Access-Token': token }) },
    { name: 'X-API-Key', getHeader: () => ({ 'X-API-Key': token }) }
  ];
  
  for (const testCase of testCases) {
    try {
      debugLog(`Тестируем формат: ${testCase.name}...`, 'info');
      
      const response = await fetch(cfg.auctionUrl + '/lots', {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          ...testCase.getHeader()
        }
      });
      
      const text = await response.text();
      
      if (response.ok) {
        debugLog(`✅ УСПЕХ! Формат ${testCase.name} работает!`, 'success');
        
        // Определяем, кастомный ли это заголовок
        if (testCase.name.includes('X-')) {
          TOKEN_CONFIG.customHeader = Object.keys(testCase.getHeader())[0];
          TOKEN_CONFIG.format = 'Custom';
          document.getElementById('tokenFormatSelect').value = testCase.name;
        } else {
          TOKEN_CONFIG.format = testCase.name;
          TOKEN_CONFIG.customHeader = null;
          document.getElementById('tokenFormatSelect').value = testCase.name;
        }
        
        saveTokenFormat();
        alert(`✅ Найден рабочий формат токена: ${testCase.name}`);
        return;
      } else {
        debugLog(`❌ Формат ${testCase.name}: ${response.status} - ${text.substring(0, 100)}`, 'error');
      }
    } catch (err) {
      debugLog(`❌ Ошибка теста ${testCase.name}: ${err.message}`, 'error');
    }
  }
  
  debugLog('❌ Ни один из форматов не сработал', 'error');
  alert('Ни один из форматов токена не сработал. Возможно, токен недействителен или сервер недоступен.');
}

function showRawToken() {
  const keys = Object.keys(state.tokens);
  if (keys.length === 0) {
    alert('Нет сохраненных токенов');
    return;
  }
  
  const tokenInfo = state.tokens[keys[0]];
  const token = tokenInfo?.token;
  
  if (!token) {
    alert('Токен не найден');
    return;
  }
  
  const modal = document.createElement('div');
  modal.style.position = 'fixed';
  modal.style.top = '50%';
  modal.style.left = '50%';
  modal.style.transform = 'translate(-50%, -50%)';
  modal.style.background = 'white';
  modal.style.padding = '20px';
  modal.style.border = '2px solid #2563eb';
  modal.style.borderRadius = '8px';
  modal.style.zIndex = '1000';
  modal.style.maxWidth = '90%';
  modal.style.maxHeight = '90%';
  modal.style.overflow = 'auto';
  
  const title = document.createElement('h4');
  title.textContent = 'Токен авторизации';
  title.style.margin = '0 0 10px 0';
  
  const info = document.createElement('div');
  info.innerHTML = `
    <div><strong>Длина:</strong> ${token.length} символов</div>
    <div><strong>Формат:</strong> ${TOKEN_CONFIG.format}</div>
    ${TOKEN_CONFIG.customHeader ? `<div><strong>Заголовок:</strong> ${TOKEN_CONFIG.customHeader}</div>` : ''}
  `;
  info.style.marginBottom = '10px';
  
  const textarea = document.createElement('textarea');
  textarea.value = token;
  textarea.style.width = '500px';
  textarea.style.height = '200px';
  textarea.style.fontFamily = 'monospace';
  textarea.style.padding = '10px';
  textarea.style.border = '1px solid #ccc';
  textarea.style.borderRadius = '4px';
  textarea.style.resize = 'none';
  
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Закрыть';
  closeBtn.className = 'btn';
  closeBtn.style.marginTop = '10px';
  closeBtn.onclick = () => document.body.removeChild(modal);
  
  modal.appendChild(title);
  modal.appendChild(info);
  modal.appendChild(textarea);
  modal.appendChild(document.createElement('br'));
  modal.appendChild(closeBtn);
  document.body.appendChild(modal);
  textarea.select();
}

function clearAllTokens() {
  if (confirm('Очистить ВСЕ токены и настройки?')) {
    localStorage.removeItem('auction_tokens');
    localStorage.removeItem('token_format');
    localStorage.removeItem('token_custom_header');
    state.tokens = {};
    TOKEN_CONFIG.format = 'Bearer';
    TOKEN_CONFIG.customHeader = null;
    document.getElementById('tokenFormatSelect').value = 'Bearer';
    saveTokens();
    debugLog('Все токены и настройки очищены', 'success');
    updateTokenStatusUI();
    alert('Все токены и настройки очищены.');
  }
}

function saveTokenFormat() {
  const format = document.getElementById('tokenFormatSelect').value;
  
  if (format === 'X-Auth-Token') {
    TOKEN_CONFIG.format = 'Custom';
    TOKEN_CONFIG.customHeader = 'X-Auth-Token';
  } else {
    TOKEN_CONFIG.format = format;
    TOKEN_CONFIG.customHeader = null;
  }
  
  localStorage.setItem('token_format', TOKEN_CONFIG.format);
  if (TOKEN_CONFIG.customHeader) {
    localStorage.setItem('token_custom_header', TOKEN_CONFIG.customHeader);
  } else {
    localStorage.removeItem('token_custom_header');
  }
  
  debugLog(`Формат токена сохранен: ${format}${TOKEN_CONFIG.customHeader ? ` (заголовок: ${TOKEN_CONFIG.customHeader})` : ''}`, 'success');
  alert(`Формат токена сохранен: ${format}`);
}

// Кнопка для включения/выключения прокси
const proxyToggleBtn = document.createElement('button');
proxyToggleBtn.className = 'btn small';
proxyToggleBtn.textContent = 'Proxy: ON';
proxyToggleBtn.style.marginLeft = '8px';
proxyToggleBtn.style.fontSize = '12px';
proxyToggleBtn.style.background = '#4ade80';
proxyToggleBtn.onclick = () => {
  PROXY_CONFIG.enabled = !PROXY_CONFIG.enabled;
  proxyToggleBtn.textContent = `Proxy: ${PROXY_CONFIG.enabled ? 'ON' : 'OFF'}`;
  proxyToggleBtn.style.background = PROXY_CONFIG.enabled ? '#4ade80' : '#f87171';
  debugLog(`Прокси ${PROXY_CONFIG.enabled ? 'включен' : 'выключен'}`, 'info');
  showMessage(`Прокси ${PROXY_CONFIG.enabled ? 'включен' : 'выключен'}`, 'info', 2000);
};

document.querySelector('.controls').appendChild(proxyToggleBtn);

// Установить сохраненный формат в селект
if (TOKEN_CONFIG.customHeader === 'X-Auth-Token') {
  document.getElementById('tokenFormatSelect').value = 'X-Auth-Token';
} else {
  document.getElementById('tokenFormatSelect').value = TOKEN_CONFIG.format;
}

// Инициализация
updateTokenStatusUI();
loadLots();
debugLog('Клиент инициализирован', 'success');
</script>
</body>
</html>