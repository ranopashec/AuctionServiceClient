<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Электронный аукцион — клиент</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; color:#111; }
    h1 { font-size: 20px; margin-bottom: 8px; }
    .controls { margin-bottom: 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    input, button, select { padding:6px 8px; font-size:14px; }
    table { border-collapse: collapse; width:100%; margin-top:12px; }
    th, td { border:1px solid #ddd; padding:8px; text-align:left; }
    th { background:#f2f2f2; }
    .small { font-size:12px; color:#666; }
    .btn { padding:6px 10px; cursor:pointer; border:1px solid #888; background:#fff; border-radius:6px; }
    .btn-primary { background:#2563eb; color:white; border-color:transparent; }
    .btn-danger { background:#ef4444; color:white; border-color:transparent; }
    .inline-edit { min-width:120px; }
    .token-info { font-size:12px; color:#075985; margin-left:8px; }
    .error { color:#b91c1c; font-weight:600; }
    .success { color:#065f46; font-weight:600; }
    #bidModal { display:none; position:fixed; left:0; top:0; right:0; bottom:0; background: rgba(0,0,0,0.4); align-items:center; justify-content:center; }
    #bidModal .panel { background:white; padding:16px; border-radius:8px; width:320px; }
    #newLotForm { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    #newLotForm input { width:200px; }
  </style>
</head>
<body>
  <h1>Клиент: Электронный аукцион — продажа земельных участков</h1>

  <div class="controls">
    <!-- Конфигурация, которую можно менять -->
    <label class="small">Auction service URL:
      <input id="cfgAuctionUrl" value="http://localhost:8080" style="width:220px" />
    </label>

    <label class="small">Payment service URL:
      <input id="cfgPaymentUrl" value="http://localhost:9000" style="width:220px" />
    </label>

    <label class="small">Organization ID:
      <input id="cfgOrgId" value="org-123" style="width:140px" />
    </label>

    <button class="btn btn-primary" id="btnReload">Загрузить лоты</button>

    <div style="margin-left:auto; display:flex; align-items:center;">
      <button class="btn" id="btnShowTokens">Токены</button>
      <div id="tokenStatus" class="token-info"></div>
    </div>
  </div>

  <div id="messages"></div>

  <h3>Добавить новый лот</h3>
  <form id="newLotForm">
    <input id="new_name" placeholder="Название" required />
    <input id="new_start_price" placeholder="Стартовая цена" type="number" step="0.01" required />
    <input id="new_auction_end_date" placeholder="Дата окончания (ISO)" value="" />
    <input id="new_description" placeholder="Описание" />
    <button class="btn btn-primary" type="submit">Создать (CreateLot)</button>
  </form>

  <h3>Список лотов</h3>
  <div class="small">Двойной клик на ячейке — редактировать. Сохранить (Save) — отправляет UpdateLot. Создание/удаление/ставки — платные методы.</div>

  <table id="lotsTable">
    <thead>
      <tr>
        <th>ID</th>
        <th>Название</th>
        <th>Описание</th>
        <th>Текущая цена</th>
        <th>Владелец</th>
        <th>Окончание аукциона</th>
        <th>Действия</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Модал для ставки -->
  <div id="bidModal">
    <div class="panel">
      <h4>Сделать ставку</h4>
      <div id="bidLotInfo"></div>
      <div style="margin-top:8px">
        <input id="bid_amount" type="number" step="0.01" placeholder="Сумма ставки" style="width:150px" />
        <button class="btn btn-primary" id="btnPlaceBid">Поставить (PlaceBid)</button>
        <button class="btn" id="btnCloseBid">Отмена</button>
      </div>
      <div id="bidMessage" class="small" style="margin-top:8px"></div>
    </div>
  </div>

<script>
/*
  Клиент предполагает следующие API (на основе представленного прикладного сервиса):

  Auction service (пример):
    GET  /lots                    -> список лотов (json array)
    GET  /lots/{id}               -> один лот (json)
    POST /lots                    -> создать (CreateLot)  [платно]
    PUT  /lots/{id}               -> обновить (UpdateLot)  [платно]
    DELETE /lots/{id}             -> удалить (DeleteLot)   [платно]
    POST /lots/{id}/bid           -> поставить ставку (PlaceBid) [платно]

  Payment service (клиент должен уметь вызывать оплату):
    POST /pay   (предположение)
        payload: { organizationId, serviceName, methodName, periodFrom, periodTo }
        response: { token: "...", expiresAt: "ISO datetime", allowedMethods: [ ... ] }

    (проверка токена сервером — как в приложении: POST /token/check)

  Ты должен привести реальные URL и endpoint оплаты в конфиге выше.

  Хранение токенов: localStorage в виде { methodName -> { token, expiresAt } }.
*/

const cfg = {
  get auctionUrl(){ return document.getElementById('cfgAuctionUrl').value.replace(/\/+$/, '') },
  get paymentUrl(){ return document.getElementById('cfgPaymentUrl').value.replace(/\/+$/, '') },
  get orgId(){ return document.getElementById('cfgOrgId').value.trim() },
  serviceName: "AuctionService"
};

const state = {
  lots: [],
  editing: new Map(), // id -> {field:value}
  tokens: loadTokens()
};

function showMessage(text, type='info', ttl=4000){
  const box = document.getElementById('messages');
  box.innerHTML = `<div class="${type==='error'?'error':type==='success'?'success':''}">${text}</div>`;
  if(ttl>0) setTimeout(()=>{ if(box.innerHTML.includes(text)) box.innerHTML=''; }, ttl);
}

function loadTokens(){
  try {
    const raw = localStorage.getItem('auction_tokens');
    return raw ? JSON.parse(raw) : {};
  } catch(e){ return {}; }
}

function saveTokens(){
  localStorage.setItem('auction_tokens', JSON.stringify(state.tokens));
  updateTokenStatusUI();
}

function updateTokenStatusUI(){
  // покажем сколько токенов и ближайшую expir
  const el = document.getElementById('tokenStatus');
  const keys = Object.keys(state.tokens);
  if(keys.length===0){ el.textContent = 'Нет токенов'; return; }
  // найдем ближайшее истечение
  let soonest = null;
  keys.forEach(k=>{
    const t = state.tokens[k].expiresAt;
    if(!t) return;
    const d = new Date(t);
    if(isNaN(d)) return;
    if(!soonest || d < soonest) soonest = d;
  });
  el.textContent = `${keys.length} токен(ов)` + (soonest ? `, ближайший истекает ${soonest.toLocaleString()}` : '');
}

function tokenForMethod(method){
  const info = state.tokens[method];
  if(!info) return null;
  if(info.expiresAt){
    const d = new Date(info.expiresAt);
    if(Date.now() > d.getTime()){
      // истек
      delete state.tokens[method];
      saveTokens();
      return null;
    }
  }
  return info.token;
}

async function fetchJson(url, opts = {}){
  const res = await fetch(url, opts);
  const text = await res.text();
  let body = null;
  try { body = text ? JSON.parse(text) : null; } catch(e){ /* ignore */ }
  if(!res.ok){
    const err = new Error((body && (body.error || body.message)) || `HTTP ${res.status}`);
    err.status = res.status;
    err.body = body;
    throw err;
  }
  return body;
}

/* ========== Payment: запрос оплаты и получение токена ========== */
/*
  Предполагаемый контракт endpoint оплаты:
  POST {paymentUrl}/pay
    body: { organizationId, serviceName, methodName, periodFrom, periodTo }
    response: { token: "...", expiresAt: "2025-11-17T22:00:00Z" }

  Если у вас другое имя/контракт — подставь.
*/
async function payForMethod(method, periodFromIso, periodToIso){
  if(!cfg.orgId){ showMessage('Укажите Organization ID', 'error'); return null; }
  const payload = {
    organizationId: cfg.orgId,
    serviceName: cfg.serviceName,
    methodName: method,
    periodFrom: periodFromIso,
    periodTo: periodToIso
  };
  try {
    const body = await fetchJson(cfg.paymentUrl + '/pay', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if(!body.token){ showMessage('Платёж завершён, но токен не возвращён', 'error'); return null; }
    state.tokens[method] = { token: body.token, expiresAt: body.expiresAt || null };
    saveTokens();
    showMessage(`Получен токен для ${method}`, 'success');
    return body.token;
  } catch(err){
    console.error('pay error', err);
    showMessage('Оплата не удалась: ' + (err.body?.error || err.message || err.status), 'error');
    return null;
  }
}

/* ========== CRUD + bid ========== */

async function loadLots(){
  try {
    const url = cfg.auctionUrl + '/lots';
    const body = await fetchJson(url);
    state.lots = Array.isArray(body) ? body : [];
    renderTable();
    showMessage('Лоты загружены', 'success', 1500);
  } catch(err){
    console.error(err);
    showMessage('Не удалось загрузить лоты: ' + (err.body?.error || err.message), 'error');
  }
}

function renderTable(){
  const tbody = document.querySelector('#lotsTable tbody');
  tbody.innerHTML = '';
  for(const lot of state.lots){
    const tr = document.createElement('tr');
    tr.dataset.id = lot.id;
    tr.innerHTML = `
      <td>${lot.id}</td>
      <td class="editable" data-field="name">${escapeHtml(lot.name ?? '')}</td>
      <td class="editable" data-field="description">${escapeHtml(lot.description ?? '')}</td>
      <td class="editable" data-field="start_price">${lot.current_price ?? lot.start_price ?? 0}</td>
      <td class="editable" data-field="owner_id">${escapeHtml(lot.owner_id ?? '')}</td>
      <td class="editable" data-field="auction_end_date">${escapeHtml(lot.auction_end_date ?? '')}</td>
      <td>
        <button class="btn" data-action="save">Save</button>
        <button class="btn" data-action="delete">Delete</button>
        <button class="btn" data-action="bid">Bid</button>
      </td>
    `;
    tbody.appendChild(tr);
  }
  // attach events for inline edit
  document.querySelectorAll('#lotsTable td.editable').forEach(td=>{
    td.ondblclick = () => {
      const prev = td.textContent;
      td.contentEditable = "true";
      td.classList.add('editing');
      td.focus();
      // on blur save to editing map (not server)
      td.onblur = () => {
        td.contentEditable = "false";
        td.onblur = null;
        const id = td.parentElement.dataset.id;
        const field = td.dataset.field;
        const newv = td.textContent.trim();
        if(!state.editing[id]) state.editing[id] = {};
        state.editing[id][field] = newv;
      };
    };
  });

  // actions
  document.querySelectorAll('#lotsTable button').forEach(btn=>{
    btn.onclick = async (e) => {
      const tr = e.target.closest('tr');
      const id = tr.dataset.id;
      const action = e.target.dataset.action;
      if(action === 'save') await handleSave(id, tr);
      if(action === 'delete') await handleDelete(id);
      if(action === 'bid') await openBidModal(id);
    };
  });
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;' }[c]));
}

async function handleSave(id, tr){
  // Подготаавливаем payload из state.editing или если отсутствует, ничего не делаем
  const edits = state.editing[id];
  if(!edits || Object.keys(edits).length === 0){ showMessage('Нет изменений для сохранения', 'info'); return; }
  // Build payload: примем, что UpdateLot поля: name, description, owner_id
  const payload = {};
  if('name' in edits) payload.name = edits.name;
  if('description' in edits) payload.description = edits.description;
  if('owner_id' in edits) payload.owner_id = edits.owner_id;
  // Возможно обновление других полей по контракту сервиса — подставь если нужно
  // Платный метод: UpdateLot
  const token = tokenForMethod('UpdateLot');
  if(!token){
    if(confirm('Для вызова UpdateLot требуется оплата. Перейти к оплате сейчас?')){
      const now = new Date();
      const later = new Date(now.getTime() + 1000*60*60*24); // +1 день по умолчанию
      await payForMethod('UpdateLot', now.toISOString(), later.toISOString());
    } else {
      return;
    }
  }

  try {
    const res = await fetchJson(cfg.auctionUrl + '/lots/' + encodeURIComponent(id), {
      method: 'PUT',
      headers: {
        'Content-Type':'application/json',
        'Authorization': 'Bearer ' + tokenForMethod('UpdateLot')
      },
      body: JSON.stringify(payload)
    });
    // обновим локально
    await loadLots();
    delete state.editing[id];
    showMessage('Lot обновлён', 'success');
  } catch(err){
    if(err.status === 401 || err.status === 403){
      showMessage('Токен недействителен/истёк. Пожалуйста, оплатите метод снова.', 'error');
    } else {
      showMessage('Ошибка при обновлении: ' + (err.body?.error || err.message), 'error');
    }
    console.error(err);
  }
}

async function handleDelete(id){
  if(!confirm('Удалить лот #' + id + '?')) return;
  const token = tokenForMethod('DeleteLot');
  if(!token){
    if(confirm('Для удаления требуется оплата DeleteLot. Перейти к оплате сейчас?')){
      const now = new Date();
      const later = new Date(now.getTime() + 1000*60*60*24);
      await payForMethod('DeleteLot', now.toISOString(), later.toISOString());
    } else return;
  }
  try {
    await fetchJson(cfg.auctionUrl + '/lots/' + encodeURIComponent(id), {
      method: 'DELETE',
      headers: { 'Authorization': 'Bearer ' + tokenForMethod('DeleteLot') }
    });
    await loadLots();
    showMessage('Lot удалён', 'success');
  } catch(err){
    console.error(err);
    showMessage('Не удалось удалить: ' + (err.body?.error || err.message), 'error');
  }
}

/* ---------- Создание нового лота (CreateLot, платный) ---------- */
document.getElementById('newLotForm').onsubmit = async (e) => {
  e.preventDefault();
  const name = document.getElementById('new_name').value.trim();
  const start_price = parseFloat(document.getElementById('new_start_price').value);
  const auction_end_date = document.getElementById('new_auction_end_date').value.trim();
  const description = document.getElementById('new_description').value.trim();

  if(!name || isNaN(start_price)){
    showMessage('Заполните имя и стартовую цену', 'error');
    return;
  }

  // Ensure token for CreateLot
  let token = tokenForMethod('CreateLot');
  if(!token){
    if(!confirm('Для создания лота требуется оплата CreateLot. Перейти к оплате сейчас?')) return;
    const now = new Date();
    const later = new Date(now.getTime() + 1000*60*60*24);
    token = await payForMethod('CreateLot', now.toISOString(), later.toISOString());
    if(!token) return;
  }

  const payload = {
    name, start_price, auction_end_date: auction_end_date || undefined,
    description: description || undefined
  };

  try {
    const created = await fetchJson(cfg.auctionUrl + '/lots', {
      method: 'POST',
      headers: {
        'Content-Type':'application/json',
        'Authorization': 'Bearer ' + tokenForMethod('CreateLot')
      },
      body: JSON.stringify(payload)
    });
    showMessage('Лот создан (id=' + (created.id ?? '?') + ')', 'success');
    // очистим форму
    document.getElementById('newLotForm').reset();
    await loadLots();
  } catch(err){
    console.error(err);
    showMessage('Ошибка при создании: ' + (err.body?.error || err.message), 'error');
  }
};

/* ---------- Ставки (bid) ---------- */
let currentBidLotId = null;
async function openBidModal(id){
  currentBidLotId = id;
  const lot = state.lots.find(l => String(l.id) === String(id));
  document.getElementById('bidLotInfo').textContent = lot ? `${lot.id} — ${lot.name} (текущая: ${lot.current_price ?? lot.start_price ?? 0})` : `Лот ${id}`;
  document.getElementById('bid_amount').value = '';
  document.getElementById('bidMessage').textContent = '';
  document.getElementById('bidModal').style.display = 'flex';
}
document.getElementById('btnCloseBid').onclick = ()=>{ document.getElementById('bidModal').style.display = 'none'; };
document.getElementById('btnPlaceBid').onclick = async ()=>{
  const amount = parseFloat(document.getElementById('bid_amount').value);
  if(isNaN(amount) || amount <= 0){ document.getElementById('bidMessage').textContent = 'Введите корректную сумму'; return;}
  // ensure token for PlaceBid
  let token = tokenForMethod('PlaceBid');
  if(!token){
    if(!confirm('Для размещения ставки требуется оплата PlaceBid. Перейти к оплате сейчас?')) return;
    const now = new Date();
    const later = new Date(now.getTime() + 1000*60*60*24);
    token = await payForMethod('PlaceBid', now.toISOString(), later.toISOString());
    if(!token) return;
  }
  try {
    const body = await fetchJson(cfg.auctionUrl + '/lots/' + encodeURIComponent(currentBidLotId) + '/bid', {
      method: 'POST',
      headers: {
        'Content-Type':'application/json',
        'Authorization':'Bearer ' + tokenForMethod('PlaceBid')
      },
      body: JSON.stringify({ bid_amount: amount })
    });
    document.getElementById('bidMessage').textContent = 'Ставка принята';
    await loadLots();
    setTimeout(()=> document.getElementById('bidModal').style.display = 'none', 800);
  } catch(err){
    console.error(err);
    document.getElementById('bidMessage').textContent = 'Ошибка: ' + (err.body?.error || err.message || err.status);
  }
};

/* ---------- UI: кнопки и init ---------- */
document.getElementById('btnReload').onclick = loadLots;
document.getElementById('btnShowTokens').onclick = () => {
  const keys = Object.keys(state.tokens || {});
  if(keys.length === 0) { alert('Токенов нет'); return; }
  let txt = 'Токены:\n';
  keys.forEach(k => txt += k + ' -> ' + (state.tokens[k].expiresAt || '(без срока)') + '\\n');
  alert(txt);
};

updateTokenStatusUI();
loadLots();

</script>
</body>
</html>
